/**
 * Response Formatter Script
 * Formats AI responses consistently and handles multi-AI synthesis
 */

const core = require('@actions/core');

/**
 * Format single AI response
 * @param {string} aiSystem - AI system name
 * @param {Object} response - AI response object
 * @param {Object} context - Request context
 * @returns {string} - Formatted response
 */
function formatSingleResponse(aiSystem, response, context) {
  if (!response.success) {
    return formatErrorResponse(aiSystem, response.error);
  }

  const icons = {
    claude: 'üß†',
    chatgpt: 'üí¨',
    copilot: 'ü§ñ',
    monica: '‚ú®'
  };

  const icon = icons[aiSystem] || 'ü§ñ';
  const timestamp = new Date().toISOString();

  let formatted = `## ${icon} ${aiSystem.charAt(0).toUpperCase() + aiSystem.slice(1)} AI Response\n\n`;
  formatted += `**Generated:** ${new Date(timestamp).toLocaleString()}\n`;
  formatted += `**Task Type:** ${context.metadata.taskType}\n`;
  formatted += `**Issue:** #${context.metadata.issueNumber}\n\n`;
  formatted += `---\n\n`;
  formatted += response.response;
  formatted += `\n\n---\n\n`;
  formatted += `**Response Metadata:**\n`;
  formatted += `- Model: ${response.metadata.model || 'N/A'}\n`;
  
  if (response.metadata.usage) {
    formatted += `- Tokens: ${response.metadata.usage.prompt_tokens || response.metadata.usage.input_tokens || 0} input, `;
    formatted += `${response.metadata.usage.completion_tokens || response.metadata.usage.output_tokens || 0} output\n`;
  }
  
  if (context.conversationHistory.permissionsGranted) {
    formatted += `- Conversation History: ${context.conversationHistory.userAIHistory.length} previous interactions\n`;
  }
  
  formatted += `\n*Response generated by ${aiSystem} via US-SPURS Multi-AI Orchestration System*\n`;

  return formatted;
}

/**
 * Format error response
 * @param {string} aiSystem - AI system name
 * @param {string} error - Error message
 * @returns {string} - Formatted error
 */
function formatErrorResponse(aiSystem, error) {
  return `## ‚ùå ${aiSystem.charAt(0).toUpperCase() + aiSystem.slice(1)} AI Error

An error occurred while processing your request:

\`\`\`
${error}
\`\`\`

**Troubleshooting Steps:**
1. Check if the AI service is available
2. Verify API credentials are configured correctly
3. Review the request format and parameters
4. Check service rate limits

Please try again or contact support if the issue persists.

*Error reported by US-SPURS Multi-AI Orchestration System*`;
}

/**
 * Format multi-AI synthesized response
 * @param {Object} responses - Object containing all AI responses
 * @param {Object} context - Request context
 * @returns {string} - Synthesized formatted response
 */
function formatMultiAIResponse(responses, context) {
  let formatted = `# üåê Multi-AI Collaborative Response\n\n`;
  formatted += `**Issue:** #${context.metadata.issueNumber} - ${context.metadata.title}\n`;
  formatted += `**Task Type:** ${context.metadata.taskType}\n`;
  formatted += `**Generated:** ${new Date().toLocaleString()}\n\n`;
  formatted += `---\n\n`;

  // Executive Summary
  formatted += `## üìã Executive Summary\n\n`;
  formatted += generateExecutiveSummary(responses, context);
  formatted += `\n\n---\n\n`;

  // Individual AI Responses
  formatted += `## ü§ñ Individual AI Contributions\n\n`;

  const aiOrder = ['claude', 'chatgpt', 'copilot', 'monica'];
  
  for (const ai of aiOrder) {
    if (responses[ai] && responses[ai].success) {
      formatted += `### ${getAIIcon(ai)} ${ai.charAt(0).toUpperCase() + ai.slice(1)}\n\n`;
      formatted += `<details>\n<summary>Click to expand ${ai} response</summary>\n\n`;
      formatted += responses[ai].response;
      formatted += `\n\n</details>\n\n`;
    }
  }

  formatted += `---\n\n`;

  // Synthesis
  formatted += `## üéØ Synthesized Recommendation\n\n`;
  formatted += generateSynthesis(responses, context);
  formatted += `\n\n---\n\n`;

  // Metadata
  formatted += `## üìä Response Metadata\n\n`;
  formatted += generateMetadataTable(responses, context);
  formatted += `\n\n`;

  formatted += `*Multi-AI response synthesized by US-SPURS Orchestration System*\n`;

  return formatted;
}

/**
 * Generate executive summary from multiple AI responses
 * @param {Object} responses - AI responses
 * @param {Object} context - Context object
 * @returns {string} - Executive summary
 */
function generateExecutiveSummary(responses, context) {
  const successfulResponses = Object.entries(responses)
    .filter(([_, response]) => response.success)
    .length;

  let summary = `This collaborative response combines insights from **${successfulResponses} AI systems** `;
  summary += `to provide a comprehensive solution for your ${context.metadata.taskType} request.\n\n`;

  summary += `**Key Highlights:**\n`;

  // Analyze responses for common themes
  const themes = extractCommonThemes(responses);
  themes.forEach((theme, index) => {
    summary += `${index + 1}. ${theme}\n`;
  });

  summary += `\n**Consensus Level:** ${calculateConsensus(responses)}%\n`;
  summary += `**Confidence Score:** ${calculateConfidence(responses)}/10\n`;

  return summary;
}

/**
 * Extract common themes from AI responses
 * @param {Object} responses - AI responses
 * @returns {Array} - Array of common themes
 */
function extractCommonThemes(responses) {
  // Simplified theme extraction
  const themes = [];

  const successfulResponses = Object.values(responses).filter(r => r.success);

  if (successfulResponses.length === 0) {
    return ['No successful responses to analyze'];
  }

  // Check for code-related themes
  const hasCode = successfulResponses.some(r => r.response.includes('```'));
  if (hasCode) {
    themes.push('All AIs provided code implementations or examples');
  }

  // Check for best practices mentions
  const hasBestPractices = successfulResponses.some(r => 
    r.response.toLowerCase().includes('best practice')
  );
  if (hasBestPractices) {
    themes.push('Multiple AIs emphasized best practices and standards');
  }

  // Check for security mentions
  const hasSecurity = successfulResponses.some(r => 
    r.response.toLowerCase().includes('security')
  );
  if (hasSecurity) {
    themes.push('Security considerations were highlighted');
  }

  // Check for testing mentions
  const hasTesting = successfulResponses.some(r => 
    r.response.toLowerCase().includes('test')
  );
  if (hasTesting) {
    themes.push('Testing strategies were recommended');
  }

  if (themes.length === 0) {
    themes.push('Comprehensive technical analysis provided');
    themes.push('Multiple perspectives on the solution approach');
  }

  return themes.slice(0, 5); // Limit to top 5 themes
}

/**
 * Calculate consensus level between AI responses
 * @param {Object} responses - AI responses
 * @returns {number} - Consensus percentage
 */
function calculateConsensus(responses) {
  const successfulResponses = Object.values(responses).filter(r => r.success);
  
  if (successfulResponses.length < 2) {
    return 100; // Single response = 100% consensus
  }

  // Simple consensus calculation based on response similarity
  let consensusScore = 0;
  let comparisons = 0;

  for (let i = 0; i < successfulResponses.length; i++) {
    for (let j = i + 1; j < successfulResponses.length; j++) {
      const similarity = calculateTextSimilarity(
        successfulResponses[i].response,
        successfulResponses[j].response
      );
      consensusScore += similarity;
      comparisons++;
    }
  }

  return comparisons > 0 ? Math.round((consensusScore / comparisons) * 100) : 100;
}

/**
 * Calculate text similarity between two responses
 * @param {string} text1 - First text
 * @param {string} text2 - Second text
 * @returns {number} - Similarity score (0-1)
 */
function calculateTextSimilarity(text1, text2) {
  // Simple keyword-based similarity
  const keywords1 = extractKeywords(text1);
  const keywords2 = extractKeywords(text2);

  const commonKeywords = keywords1.filter(k => keywords2.includes(k));
  const totalKeywords = new Set([...keywords1, ...keywords2]).size;

  return totalKeywords > 0 ? commonKeywords.length / totalKeywords : 0;
}

/**
 * Extract keywords from text
 * @param {string} text - Text to analyze
 * @returns {Array} - Array of keywords
 */
function extractKeywords(text) {
  const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been', 'being'];
  
  const words = text.toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !stopWords.includes(word));

  // Count word frequency
  const frequency = {};
  words.forEach(word => {
    frequency[word] = (frequency[word] || 0) + 1;
  });

  // Return top keywords
  return Object.entries(frequency)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 20)
    .map(([word]) => word);
}

/**
 * Calculate confidence score from responses
 * @param {Object} responses - AI responses
 * @returns {number} - Confidence score (0-10)
 */
function calculateConfidence(responses) {
  const successfulResponses = Object.values(responses).filter(r => r.success);
  
  if (successfulResponses.length === 0) {
    return 0;
  }

  // Base confidence on number of successful responses and response quality
  const baseScore = (successfulResponses.length / Object.keys(responses).length) * 5;
  
  // Add points for comprehensive responses
  const avgLength = successfulResponses.reduce((sum, r) => sum + r.response.length, 0) / successfulResponses.length;
  const lengthScore = Math.min(avgLength / 500, 3); // Up to 3 points for length
  
  // Add points for code examples
  const hasCode = successfulResponses.some(r => r.response.includes('```'));
  const codeScore = hasCode ? 2 : 0;

  const totalScore = baseScore + lengthScore + codeScore;
  
  return Math.min(Math.round(totalScore), 10);
}

/**
 * Generate synthesis of all AI responses
 * @param {Object} responses - AI responses
 * @param {Object} context - Context object
 * @returns {string} - Synthesized recommendation
 */
function generateSynthesis(responses, context) {
  const successfulResponses = Object.entries(responses).filter(([_, r]) => r.success);

  if (successfulResponses.length === 0) {
    return '‚ö†Ô∏è No successful responses were received from the AI systems. Please try again or check system status.';
  }

  let synthesis = `Based on the analysis from ${successfulResponses.length} AI system(s), here is the synthesized recommendation:\n\n`;

  // Determine primary approach
  synthesis += `### üéØ Recommended Approach\n\n`;
  synthesis += generatePrimaryApproach(responses, context);
  synthesis += `\n\n`;

  // Key considerations
  synthesis += `### üîë Key Considerations\n\n`;
  synthesis += generateKeyConsiderations(responses);
  synthesis += `\n\n`;

  // Implementation steps
  synthesis += `### üìù Implementation Steps\n\n`;
  synthesis += generateImplementationSteps(responses, context);
  synthesis += `\n\n`;

  // Alternative approaches
  if (successfulResponses.length > 1) {
    synthesis += `### üîÑ Alternative Approaches\n\n`;
    synthesis += generateAlternatives(responses);
    synthesis += `\n\n`;
  }

  // Best practices
  synthesis += `### ‚úÖ Best Practices to Follow\n\n`;
  synthesis += generateBestPractices(responses);
  synthesis += `\n\n`;

  // Next steps
  synthesis += `### üöÄ Next Steps\n\n`;
  synthesis += generateNextSteps(responses, context);

  return synthesis;
}

/**
 * Generate primary approach recommendation
 * @param {Object} responses - AI responses
 * @param {Object} context - Context object
 * @returns {string} - Primary approach
 */
function generatePrimaryApproach(responses, context) {
  const taskType = context.metadata.taskType;
  
  let approach = '';

  switch (taskType) {
    case 'code-generation':
      approach = 'The AIs recommend a modular, well-documented approach with:\n';
      approach += '- Clear separation of concerns\n';
      approach += '- Comprehensive error handling\n';
      approach += '- Production-ready code quality\n';
      approach += '- Extensive inline documentation\n';
      break;

    case 'code-review':
      approach = 'The review process should focus on:\n';
      approach += '- Code quality and maintainability\n';
      approach += '- Security vulnerabilities\n';
      approach += '- Performance optimization opportunities\n';
      approach += '- Best practices adherence\n';
      break;

    case 'bug-fix':
      approach = 'The bug fix strategy includes:\n';
      approach += '- Root cause identification\n';
      approach += '- Comprehensive testing of the fix\n';
      approach += '- Prevention of similar issues\n';
      approach += '- Documentation of the solution\n';
      break;

    case 'architecture':
      approach = 'The architectural design should prioritize:\n';
      approach += '- Scalability and performance\n';
      approach += '- Maintainability and modularity\n';
      approach += '- Security and reliability\n';
      approach += '- Future extensibility\n';
      break;

    default:
      approach = 'The recommended approach emphasizes:\n';
      approach += '- Clear problem understanding\n';
      approach += '- Systematic solution development\n';
      approach += '- Quality assurance\n';
      approach += '- Comprehensive documentation\n';
  }

  return approach;
}

/**
 * Generate key considerations
 * @param {Object} responses - AI responses
 * @returns {string} - Key considerations
 */
function generateKeyConsiderations(responses) {
  const considerations = [];

  const allResponses = Object.values(responses)
    .filter(r => r.success)
    .map(r => r.response.toLowerCase());

  // Check for common themes
  if (allResponses.some(r => r.includes('security'))) {
    considerations.push('**Security**: Implement proper input validation, authentication, and authorization');
  }

  if (allResponses.some(r => r.includes('performance') || r.includes('scalability'))) {
    considerations.push('**Performance**: Optimize for efficiency and scalability from the start');
  }

  if (allResponses.some(r => r.includes('test') || r.includes('testing'))) {
    considerations.push('**Testing**: Develop comprehensive test coverage including unit and integration tests');
  }

  if (allResponses.some(r => r.includes('error') || r.includes('exception'))) {
    considerations.push('**Error Handling**: Implement robust error handling and logging mechanisms');
  }

  if (allResponses.some(r => r.includes('document') || r.includes('comment'))) {
    considerations.push('**Documentation**: Maintain clear documentation for future maintainability');
  }

  if (allResponses.some(r => r.includes('maintainability') || r.includes('readable'))) {
    considerations.push('**Code Quality**: Write clean, readable, and maintainable code');
  }

  // Add default considerations if none found
  if (considerations.length === 0) {
    considerations.push('**Quality**: Focus on code quality and best practices');
    considerations.push('**Reliability**: Ensure robust error handling and edge case coverage');
    considerations.push('**Maintainability**: Write clear, well-documented code');
  }

  return considerations.map((c, i) => `${i + 1}. ${c}`).join('\n');
}

/**
 * Generate implementation steps
 * @param {Object} responses - AI responses
 * @param {Object} context - Context object
 * @returns {string} - Implementation steps
 */
function generateImplementationSteps(responses, context) {
  const steps = [
    '**Planning Phase**\n   - Review all AI recommendations\n   - Identify the best approach for your specific use case\n   - Plan the implementation timeline',
    
    '**Development Phase**\n   - Implement core functionality following best practices\n   - Write clean, well-documented code\n   - Include comprehensive error handling',
    
    '**Testing Phase**\n   - Develop unit tests for all components\n   - Perform integration testing\n   - Test edge cases and error scenarios',
    
    '**Review Phase**\n   - Conduct code review\n   - Verify security considerations\n   - Ensure documentation is complete',
    
    '**Deployment Phase**\n   - Deploy to staging environment first\n   - Monitor for issues\n   - Deploy to production with rollback plan'
  ];

  return steps.map((step, i) => `${i + 1}. ${step}`).join('\n\n');
}

/**
 * Generate alternative approaches
 * @param {Object} responses - AI responses
 * @returns {string} - Alternative approaches
 */
function generateAlternatives(responses) {
  const alternatives = [];

  const aiNames = Object.entries(responses)
    .filter(([_, r]) => r.success)
    .map(([name]) => name);

  if (aiNames.length > 1) {
    alternatives.push(`Different AI systems provided varying perspectives on the solution. Consider reviewing each approach to determine which best fits your specific requirements.`);
    
    alternatives.push(`\n**Comparative Analysis:**`);
    
    aiNames.forEach(ai => {
      const icon = getAIIcon(ai);
      alternatives.push(`- ${icon} **${ai.charAt(0).toUpperCase() + ai.slice(1)}**: Focuses on ${getAIStrength(ai)}`);
    });
  }

  return alternatives.join('\n');
}

/**
 * Get AI system icon
 * @param {string} aiSystem - AI system name
 * @returns {string} - Icon
 */
function getAIIcon(aiSystem) {
  const icons = {
    claude: 'üß†',
    chatgpt: 'üí¨',
    copilot: 'ü§ñ',
    monica: '‚ú®'
  };
  return icons[aiSystem] || 'ü§ñ';
}

/**
 * Get AI system strength
 * @param {string} aiSystem - AI system name
 * @returns {string} - Strength description
 */
function getAIStrength(aiSystem) {
  const strengths = {
    claude: 'detailed analysis and comprehensive explanations',
    chatgpt: 'practical solutions and clear communication',
    copilot: 'code generation and development best practices',
    monica: 'creative solutions and user experience'
  };
  return strengths[aiSystem] || 'general problem-solving';
}

/**
 * Generate best practices
 * @param {Object} responses - AI responses
 * @returns {string} - Best practices
 */
function generateBestPractices(responses) {
  const practices = [
    '‚úÖ Follow coding standards and style guides for your language/framework',
    '‚úÖ Implement comprehensive error handling and logging',
    '‚úÖ Write unit tests with good coverage',
    '‚úÖ Document your code with clear comments and README files',
    '‚úÖ Use version control effectively with meaningful commit messages',
    '‚úÖ Conduct code reviews before merging',
    '‚úÖ Consider security implications at every step',
    '‚úÖ Optimize for performance and scalability',
    '‚úÖ Keep dependencies up to date',
    '‚úÖ Monitor and log application behavior in production'
  ];

  return practices.join('\n');
}

/**
 * Generate next steps
 * @param {Object} responses - AI responses
 * @param {Object} context - Context object
 * @returns {string} - Next steps
 */
function generateNextSteps(responses, context) {
  const steps = [];

  steps.push('1. **Review** all AI recommendations and choose the approach that best fits your needs');
  steps.push('2. **Implement** the solution following the recommended best practices');
  steps.push('3. **Test** thoroughly in a development environment');
  steps.push('4. **Document** your implementation and any deviations from the recommendations');
  steps.push('5. **Deploy** with proper monitoring and rollback procedures');
  steps.push('6. **Iterate** based on feedback and performance metrics');

  if (context.conversationHistory.permissionsGranted) {
    steps.push('\nüí° **Tip**: Your conversation history is being tracked to provide better context in future interactions!');
  } else {
    steps.push('\nüí° **Tip**: Consider enabling conversation history with `/consent grant-all` for more contextual responses!');
  }

  return steps.join('\n');
}

/**
 * Generate metadata table
 * @param {Object} responses - AI responses
 * @param {Object} context - Context object
 * @returns {string} - Metadata table
 */
function generateMetadataTable(responses, context) {
  let table = '| AI System | Status | Response Length | Tokens Used |\n';
  table += '|-----------|--------|-----------------|-------------|\n';

  Object.entries(responses).forEach(([ai, response]) => {
    const icon = getAIIcon(ai);
    const status = response.success ? '‚úÖ Success' : '‚ùå Failed';
    const length = response.success ? `${response.response.length} chars` : 'N/A';
    
    let tokens = 'N/A';
    if (response.success && response.metadata.usage) {
      const input = response.metadata.usage.prompt_tokens || response.metadata.usage.input_tokens || 0;
      const output = response.metadata.usage.completion_tokens || response.metadata.usage.output_tokens || 0;
      tokens = `${input + output}`;
    }

    table += `| ${icon} ${ai.charAt(0).toUpperCase() + ai.slice(1)} | ${status} | ${length} | ${tokens} |\n`;
  });

  table += '\n**Additional Context:**\n';
  table += `- Conversation History: ${context.conversationHistory.permissionsGranted ? 'Enabled' : 'Disabled'}\n`;
  table += `- Privacy Consent: ${context.privacyMetadata.consentStatus}\n`;
  table += `- Task Type: ${context.metadata.taskType}\n`;
  table += `- Generated: ${new Date().toISOString()}\n`;

  return table;
}

/**
 * Format conversation history summary
 * @param {Object} conversationHistory - Conversation history object
 * @returns {string} - Formatted summary
 */
function formatConversationHistorySummary(conversationHistory) {
  if (!conversationHistory.permissionsGranted) {
    return 'üîí Conversation history is not enabled. Use `/consent grant-all` to enable.';
  }

  let summary = '## üìö Conversation History Summary\n\n';
  
  summary += `**Permission Status:** ‚úÖ Granted (${conversationHistory.permissionScope})\n\n`;

  if (conversationHistory.userAIHistory.length > 0) {
    summary += `### Recent Interactions\n\n`;
    summary += `You have ${conversationHistory.userAIHistory.length} previous interactions with this AI system.\n\n`;
    
    summary += `**Recent Topics:**\n`;
    conversationHistory.userAIHistory.slice(0, 5).forEach((conv, i) => {
      const date = new Date(conv.metadata?.createdAt || Date.now()).toLocaleDateString();
      const taskType = conv.metadata?.taskType || 'general';
      summary += `${i + 1}. ${taskType} (${date})\n`;
    });
  }

  if (conversationHistory.projectHistory.length > 0) {
    summary += `\n### Project Context\n\n`;
    summary += `${conversationHistory.projectHistory.length} project-related conversations available.\n`;
  }

  return summary;
}

/**
 * Format AI comparison table
 * @param {Object} responses - AI responses
 * @returns {string} - Comparison table
 */
function formatAIComparisonTable(responses) {
  let table = '## üîç AI System Comparison\n\n';
  table += '| Feature | Claude üß† | ChatGPT üí¨ | Copilot ü§ñ | Monica ‚ú® |\n';
  table += '|---------|-----------|------------|------------|----------|\n';

  // Response status
  const statusRow = ['**Status**'];
  ['claude', 'chatgpt', 'copilot', 'monica'].forEach(ai => {
    statusRow.push(responses[ai]?.success ? '‚úÖ' : '‚ùå');
  });
  table += `| ${statusRow.join(' | ')} |\n`;

  // Response length
  const lengthRow = ['**Length**'];
  ['claude', 'chatgpt', 'copilot', 'monica'].forEach(ai => {
    const length = responses[ai]?.success ? `${Math.round(responses[ai].response.length / 100) * 100}+` : 'N/A';
    lengthRow.push(length);
  });
  table += `| ${lengthRow.join(' | ')} |\n`;

  // Has code
  const codeRow = ['**Code Examples**'];
  ['claude', 'chatgpt', 'copilot', 'monica'].forEach(ai => {
    const hasCode = responses[ai]?.success && responses[ai].response.includes('```') ? '‚úÖ' : '‚ùå';
    codeRow.push(hasCode);
  });
  table += `| ${codeRow.join(' | ')} |\n`;

  // Strength
  const strengthRow = ['**Strength**'];
  ['claude', 'chatgpt', 'copilot', 'monica'].forEach(ai => {
    strengthRow.push(getAIStrength(ai).split(' ').slice(0, 2).join(' '));
  });
  table += `| ${strengthRow.join(' | ')} |\n`;

  return table;
}

// Export functions
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    formatSingleResponse,
    formatErrorResponse,
    formatMultiAIResponse,
    generateExecutiveSummary,
    extractCommonThemes,
    calculateConsensus,
    calculateTextSimilarity,
    extractKeywords,
    calculateConfidence,
    generateSynthesis,
    generatePrimaryApproach,
    generateKeyConsiderations,
    generateImplementationSteps,
    generateAlternatives,
    getAIIcon,
    getAIStrength,
    generateBestPractices,
    generateNextSteps,
    generateMetadataTable,
    formatConversationHistorySummary,
    formatAIComparisonTable
  };
}
